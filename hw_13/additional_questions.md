### **1. Як можна інтегрувати асинхронний код у вже існуючий синхронний проект на Python?**

---

#### **1.1. Використання циклу подій**

Асинхронний код в Python працює на основі циклу подій (`event loop`), який керує виконанням корутин (асинхронних
функцій). У синхронному проекті цикл подій зазвичай не запущений, тому для виконання асинхронного коду потрібно створити
новий цикл подій або інтегрувати його в існуючий контекст.

Якщо асинхронна функція викликається з синхронного коду, можна використовувати метод `asyncio.run()`, який створює
тимчасовий цикл подій і виконує асинхронну функцію.

Якщо вже є активний цикл подій (наприклад, у веб-сервері), використання `asyncio.run()` призведе до помилки. У такому
випадку потрібно отримати доступ до поточного циклу подій за допомогою `asyncio.get_event_loop()`.

---

#### **1.2. Виконання синхронного коду в асинхронному контексті**

Якщо синхронний код (наприклад, блокуючі операції, такі як робота з файлами або базами даних) викликається в
асинхронному контексті, він може заблокувати цикл подій, що призведе до сповільнення всього асинхронного коду.

Для запуску синхронного коду в асинхронному контексті можна використовувати метод `loop.run_in_executor()`. Цей метод
дозволяє виконувати синхронний код у окремому потоці або процесі, не блокуючи цикл подій.

Потоки (`threading`) використовуються для легковагих завдань, таких як I/O-операції, а процеси (`multiprocessing`) — для
обчислювально важких задач.

---

#### **1.3. Розбиття проекту на синхронну і асинхронну частини**

Якщо проект має значну кількість синхронного коду, можна розділити його на дві частини:

- Синхронна частина: виконує основну логіку програми.
- Асинхронна частина: відповідає за завдання, які вимагають паралелізму, наприклад, мережеві запити або роботу з базами
  даних.

Ці частини можуть взаємодіяти через інтерфейси, такі як черги (`queue.Queue` або `asyncio.Queue`), або через спеціальні
механізми синхронізації, такі як семафори, блокування або події.

---

#### **1.4. Перехід до повністю асинхронного проекту**

Якщо проект планується розширювати або вимагає високої продуктивності, можна поступово переписувати синхронний код на
асинхронний. Це потребує:

- Заміни синхронних бібліотек на їх асинхронні аналоги (наприклад, `requests` → `aiohttp`).
- Рефакторингу логіки програми для використання корутин замість звичайних функцій.
- Тестування, щоб переконатися, що асинхронний код працює коректно і не створює проблем із синхронними частинами.

---

### **2. Які підводні камені використання асинхронних бібліотек при роботі з базами даних?**

---

#### **2.1. Блокуючі операції**

Багато драйверів баз даних (наприклад, `psycopg2` для PostgreSQL або `pymysql` для MySQL) є синхронними і блокують
виконання. Якщо ми використовуємо такий драйвер у асинхронному коді, це може призвести до блокування циклу подій, що
зробить весь асинхронний код непрацездатним.

Для уникнення цього можна використовувати асинхронні драйвери, такі як `asyncpg` (PostgreSQL) або `motor` (MongoDB).

---

#### **2.2. Конкуренція за підключення**

У асинхронному середовищі кілька задач можуть спробувати одночасно використовувати одне підключення до бази даних. Це
може призвести до конфліктів, неправильного стану або помилок.

Для вирішення цієї проблеми використовуються пули підключень (`connection pool`). Пул керує доступом до бази даних,
надаючи кожній задачі окреме підключення.

---

#### **2.3. Транзакції**

Транзакції в асинхронних програмах можуть бути складними через те, що одна транзакція повинна бути оброблена лише одним
завданням. Якщо декілька задач намагаються змінювати дані в рамках однієї транзакції, це може призвести до
неконсистентного стану.

Для управління транзакціями в асинхронному коді використовуються менеджери контексту, які автоматично відкривають і
закривають транзакції.

---

#### **2.4. Обмеження на кількість паралельних запитів**

Деякі бази даних мають обмеження на кількість одночасних підключень. Якщо ми створюємо занадто багато паралельних
запитів, це може призвести до помилок або відмови бази даних.

Для обмеження кількості одночасних запитів можна використовувати семафори (`asyncio.Semaphore`), які дозволяють
контролювати паралелізм.

---

#### **2.5. Повільні запити**

Повільні запити до бази даних можуть блокувати цикл подій, навіть якщо вони виконуються асинхронно. Це може призвести до
затримок у виконанні інших завдань.

Для оптимізації запитів слід використовувати індекси для прискорення пошуку, аналізувати план виконання запитів та
розподіляти навантаження між різними серверами баз даних.

---

#### **2.6. Підтримка асинхронності в ORM**

Багато відомих ORM (наприклад, SQLAlchemy) не підтримують асинхронність з коробки. Це може створювати проблеми при
інтеграції ORM у асинхронний проект.

Для роботи з асинхронними базами даних рекомендується використовувати асинхронні ORM, такі як `Tortoise ORM` або
експериментальну підтримку асинхронності в `SQLAlchemy 2.0`.

Якщо використовується синхронний ORM, його можна запускати в окремому потоці за допомогою `run_in_executor`.
